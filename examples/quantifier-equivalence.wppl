// quantifierEquivalence goes from a representation of objects with properties
// to a representation of the relations between the properties
// (spec., the truth-value of possible quantifier utterances)
// this is useful preprocessing for models that do inference over states (e.g. RSA) 
// where the identity of the objects doesn't matter, since the state space (that goes into RSA)
// doesn't depend upon the number of objects (but is fixed to space of sentences)

// logic
var A_is_B = function(obj){
  return (obj[0] && obj[1])
}

var not_A = function(obj){
  return !(obj[0])
}

var all_A_are_B = function(a, b){
  return all(function(x){return (not_A(x) || A_is_B(x))}, _.zip(a,b))
}

var some_A_are_B = function(a, b){
  return any(A_is_B, _.zip(a,b)) && any(function(x){return x}, a)
}

var meaning = function(quantifier){
  return quantifier=="all"? all_A_are_B :
         quantifier=="some"? some_A_are_B :
         quantifier=="none"? function(a,b){return !(some_A_are_B(a,b))} :
         quantifier=="not all"? function(a,b){return !(all_A_are_B(a,b))} : 
         true
}

var utterances = ["all","some","not all","none"]
var properties =  ["A","B","C"]

var propertyOrders = _.flatten(
  map(function(p){
    var props = ["A","B","C"]
    props.splice(props.indexOf(p), 1)
    return map(function(x){return [x,p]}, props)
  }, properties), 
true)

// utterances are a quantifier relation, and two properties (e.g. some As are Bs)
var utterancesAboutProperties = _.flatten(map(function(q){
  return map(function(o){
    return [q, o]
  }, propertyOrders)
}, utterances), true)

var quantifierEquivalence = cache(function(n_objects, base_rate){
  Enumerate(function(){

    // objects, lists of properties: order corresponds to object id
    var objects = {
      A: repeat(n_objects, function(x){return flip(base_rate)}),
      B: repeat(n_objects, function(x){return flip(base_rate)}),
      C: repeat(n_objects, function(x){return flip(base_rate)})
    }

    // for each possible utterance -- property pairing
    // compute truth value
   return _.object(map(function(utt){
      var q = utt[0]
      var property1 = utt[1][0]
      var property2 = utt[1][1]
      return [utt.join(''), 
              meaning(q)(objects[property1], objects[property2])]
    },utterancesAboutProperties))

  })
})


quantifierEquivalence(3, 0.25)